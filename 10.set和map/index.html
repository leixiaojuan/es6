<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>set和map数据结构</title>
  </head>
  <body>

  </body>
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js"></script> -->
  <script type="text/javascript">
    function log(data) {
      return console.log(`%c${data}`, 'color: red')
    }
    {
      log('Set 结构不会添加重复的值。由于两个空对象不相等，所以它们被视为两个值。')
      let s = new Set()
      var arr = [1, 2, 4, 1, 2, 4]
      arr.forEach((v, i) => {
        s.add(v)
      })

      console.log(s)
      console.log([...s])
    }

    {
      log('一行代码快速去重')
      var arr = ['a', 'b', 'c', 'a', 'd', 'b']

      console.log([...new Set(arr)])
    }

    {
      log('对象可以重复添加。 不相等')
      var a = {
        x: 1
      }

      var b = {
        x: 1
      }

      var c = new Set()

      c.add(a)

      c.add(b)

      console.log(c)
    }

    {
      // add(value)：添加某个值，返回Set结构本身。
      // delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
      // has(value)：返回一个布尔值，表示该值是否为Set的成员。
      // clear()：清除所有成员，没有返回值。
      let s = new Set()
      s.add(1).add(2).add(2)
      console.log(s)
      console.log(s.has(1))
    }

    {
      log('WeakSet')
      // 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，
      // 那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
      //
      // 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。
      // 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，
      // 都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。.
      // 只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
      //
      // 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
      // 另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，
      // 而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。
      const a = [[1, 2], [3, 4]]

      let ws = new WeakSet(a)
      console.log(ws)
    }

    {
      log('map')
      // Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。
      const m = new Map()
      const o = {
        p: 'Hello World'
      }
      m.set(o, 'content')
      console.log(m.get(o))
      console.log([...m.keys()])
    }

    {
      // WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用
    }
  </script>
</html>
